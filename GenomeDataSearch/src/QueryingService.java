import java.io.EOFException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.TreeMap;

/**
 * A querying service that executes searches against the index file generated by {@link IndexingService} to access the data in
 * the RandomAccessFile. Index file is built once first and is statically available to resources that need to consume it via this service
 * 
 * @author maryammoslemi
 * 
 */
public class QueryingService {

	/**
	 * The main method that executes a query against the index
	 * 
	 * @param indexFileName
	 *            - speaks for itself
	 * @param dataFileName
	 *            - The RandomAccessFile stored on disk to be used for retrieval
	 *            of data
	 * @param startPosition
	 *            - The endPosition after we parse the user query
	 * @param endPosition
	 *            - The startPosition after we parse the user query
	 * @param chrs
	 *            - The array that represent one or two different chromosome
	 *            types 
	 *            
	 *            E.G query:chr18:0-60000000 chrs = chr18, startPosition =
	 *            0, endPosition = 600000 
	 *            E.G query: chr3:5000-chr5:8000 chrs =
	 *            {chr3, chr4, chr5}, startPosition = 5000, endPosition = 8000
	 */
	public String query(int startPosition,
			int endPosition, String chrs[]) {

		String output = "";

		try {
			// Open the data file
			RandomAccessFile dataFile = new RandomAccessFile(IndexingService.GENOME_DATA, "rw");
			byte[] block;
			
			int end;
		
			
			// If we have query spanning over multiple chromosomes we need to update the end position for the first 
			// chromosome at querying time and compute overlaps
			boolean moreThanOne = chrs.length > 1;
			end = moreThanOne ? IndexingService.startIndexes.get(chrs[0]).lastKey() :endPosition;
			output = output.concat(addOverlaps(chrs[0], startPosition, end, dataFile));

			int start;
			int numOfChromosomes = chrs.length;
			
			// Process all the chromosomes in between and grab all the data for them. Skip the first and the last one because we deal with those chromosomes separately. 
			for (int i = 1; i < numOfChromosomes - 1; i++) {
				// At this point we want to grab all the data associated with this chromosome and start positions are already
				// sorted and sorted in a Treemap in the index so we can just grab the first and last entry addresses and be sure that would contain the start and 
				// end address for this chormsome in the data block
				start = IndexingService.startIndexes.get(chrs[i]).firstEntry()
						.getValue();
				// end is the last start position for this chromosome
				end = IndexingService.startIndexes.get(chrs[i]).lastEntry().getValue();
				
				block = new byte[end - start];
				
				// Go the position of the address and read the data file
				dataFile.seek(start);
				dataFile.read(block, 0, block.length);
				output = output.concat(new String(block));
			}
			
			// If we have multiple chromosomes we need to update the start position for the last chromosome at querying time and check for overlaps
			if (moreThanOne) {
				start = IndexingService.startIndexes.get(chrs[numOfChromosomes-1]).firstKey();
				output = output.concat(addOverlaps(chrs[numOfChromosomes - 1], start, endPosition, dataFile));
			}

			dataFile.close();

		} catch (EOFException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return output;
	}

	/**
	 * This method handles grabbing all the data for the first and last chromosome in the query because we need to compute overlaps for them. The way we do this is:
	 * Binary search for the given start and end position in the the Treemap and find the closest matches to them - this takes O(logn). This needs to be done because
	 * user queries doesn't necessarily match perfectly with start positions in the input. 
	 * Complexity = O(logn)
	 */
	private String addOverlaps(String chr, int startPosition,
			int endPosition, RandomAccessFile dataFile) {
		
		// Grab the index block holding the start and end positions and corresponding addresses for this chromosome
		TreeMap<Integer, Integer> chrStartIndexBlock = IndexingService.startIndexes.get(chr);
		TreeMap<Integer, Integer> chrEndIndexBlock = IndexingService.endIndexes.get(chr);

		
		Integer[] allStarts = chrStartIndexBlock.keySet().toArray(new Integer[0]);
		
		// Do a binary search to find the closest start to the user query startPosition
		// start > startPosition
		int firstPosition = search(startPosition, allStarts, true);
		
		// Do a binary search to find the closest start to the user query endPosition
		// start < endPosition
		int lastPosition = search(endPosition, allStarts, false);
		
		int firstStartAddress = chrStartIndexBlock.get(firstPosition);
		int lastStartAddress = chrStartIndexBlock.get(lastPosition);

		Integer[] allEnds = chrEndIndexBlock.keySet()
				.toArray(new Integer[0]);
		
		// Do a binary search to find the closest end to the startPosition
		// end > startPosition
		firstPosition = search(startPosition, allEnds, true);
		
		// Do a binary search to find the closest end to the endPosition 
		// end < endPosition
		lastPosition = search(endPosition, allEnds, false);

		// Get the minimum between smallest start address and smallest end address so that we cover the whole area
		int finalStartAddress = Math.min(chrEndIndexBlock.get(firstPosition),firstStartAddress);
		// Get the maximum between largest start address and largest end address so that we cover the whole area
		int finalEndAddress = Math.max(chrEndIndexBlock.get(lastPosition),lastStartAddress);
		
		byte[] dataBlock = new byte[finalEndAddress - finalStartAddress];
		
		try {
			dataFile.seek(finalStartAddress);
			dataFile.read(dataBlock, 0, dataBlock.length);

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return new String(dataBlock);
	}
	
	/**
	 * Execute a binary search in the position values and return the closest value to #position in the #points array
	 * 
	 * @param largerThanPosition This is used to determine if we should return the lower end or upper end. When we are looking for starts we always return the upper and when
	 * we are searching for end positions we return the lower end to make sure the addresses returned are within the range of the user query
	 */
	private int search(int position, Integer[] points, boolean largerThanPosition) {
		int lo = 0;
		int hi = points.length - 1;

		int lastValue = 0;
		int mid = 0;
		while (lo <= hi) {
			mid = (lo + hi) / 2;
			lastValue = points[mid];
			if (position < lastValue) {
				hi = mid - 1;
			} else if (position > lastValue) {
				lo = mid + 1;
			} else {
				return lastValue;
			}
		}
		if (largerThanPosition) {
			if(lastValue > position || mid == points.length -1) 
				return lastValue;
		 else
				return points[mid+1];
		} 
		else if (lastValue < position || mid == 0)
			return lastValue;
		else
			return points[mid-1];
	
		}

}
